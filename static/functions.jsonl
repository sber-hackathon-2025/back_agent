{"name": "expire", "parameters": "(self)", "start_line": 31, "end_line": 35, "content": "def expire(self):\n        items = list(self.raw.keys())\n        for key in items:\n            if self[key].check_expire():\n                self.clear(key)", "id": "6cd5b5fb-51d9-40a1-bc28-53cf756fc983", "path": "/Users/dmitrii.proskurin/PycharmProjects/sber-hackathon-2025/repos/smart_app_framework/core/basic_models/counter/counters.py"}
{"name": "raw", "parameters": "(self)", "start_line": 38, "end_line": 47, "content": "def raw(self):\n        for name in self._items:\n            counter = self._items[name]\n            value = counter.raw\n            if value:\n                self._raw_items[name] = value\n            else:\n                if name in self._raw_items:\n                    self._raw_items.pop(name)\n        return self._raw_items", "id": "301b405c-abbc-4a09-b280-7ac93a996f32", "path": "/Users/dmitrii.proskurin/PycharmProjects/sber-hackathon-2025/repos/smart_app_framework/core/basic_models/counter/counters.py"}
{"name": "_update", "parameters": "(self, value, lifetime)", "start_line": 23, "end_line": 28, "content": "def _update(self, value, lifetime):\n        self.value = self.value or 0\n        self.value += value\n        self.update_time = int(time())\n        if self.lifetime is None:\n            self.lifetime = lifetime", "id": "c4ef7741-5245-4344-980d-71064c547f93", "path": "/Users/dmitrii.proskurin/PycharmProjects/sber-hackathon-2025/repos/smart_app_framework/core/basic_models/counter/counter.py"}
{"name": "_set", "parameters": "(self, value, reset_time=False, time_shift=0)", "start_line": 34, "end_line": 38, "content": "def _set(self, value, reset_time=False, time_shift=0):\n        self.value = value\n        self.update_time = int(time()) + time_shift\n        if reset_time:\n            self.create_time = self.update_time", "id": "76517841-b7cd-4ec6-8d3e-7e9335b058a7", "path": "/Users/dmitrii.proskurin/PycharmProjects/sber-hackathon-2025/repos/smart_app_framework/core/basic_models/counter/counter.py"}
{"name": "_get_eq_value", "parameters": "(self, amount)", "start_line": 64, "end_line": 69, "content": "def _get_eq_value(self, amount):\n        if amount is None:\n            value = self.value\n        else:\n            value = self.value or 0\n        return value", "id": "4d88afdf-8830-4522-b93a-e119ceb5f953", "path": "/Users/dmitrii.proskurin/PycharmProjects/sber-hackathon-2025/repos/smart_app_framework/core/basic_models/counter/counter.py"}
{"name": "raw", "parameters": "(self)", "start_line": 72, "end_line": 79, "content": "def raw(self) -> Dict[str, int]:\n        if self.value is not None:\n            return {\n                \"value\": self.value,\n                \"create_time\": self.create_time,\n                \"update_time\": self.update_time,\n                \"lifetime\": self.lifetime\n            }", "id": "ddf79a8b-9734-43b2-bf04-bc840cbaac78", "path": "/Users/dmitrii.proskurin/PycharmProjects/sber-hackathon-2025/repos/smart_app_framework/core/basic_models/counter/counter.py"}
{"name": "_answer_template", "parameters": "(self, intent: str, score: float, is_other: bool)", "start_line": 37, "end_line": 41, "content": "def _answer_template(self, intent: str, score: float, is_other: bool) -> Dict[str, Union[str, float, bool]]:\n        # Любой классификатор должен возвращать отсортированный список наиболее вероятных вариантов из заданного\n        # множества, прошедших определенный порог уверенности. Каждый вариант из списка должен соответвовать общему\n        # шаблону: answer=классу, score=величине уверенности в ответе, other=булево значение (принадлежность к other).\n        return {cls_const.ANSWER_KEY: intent, cls_const.SCORE_KEY: score, self.class_other: is_other}", "id": "f4b86fae-4a2d-472c-91a2-19887a0d64fa", "path": "/Users/dmitrii.proskurin/PycharmProjects/sber-hackathon-2025/repos/smart_app_framework/core/basic_models/classifiers/basic_classifiers.py"}
{"name": "find_best_answer", "parameters": "(\n            self,\n            text_preprocessing_result: BaseTextPreprocessingResult,\n            mask: Optional[Dict[str, bool]] = None,\n            scenario_classifiers: Optional[Dict[str, Any]] = None\n    )", "start_line": 154, "end_line": 172, "content": "def find_best_answer(\n            self,\n            text_preprocessing_result: BaseTextPreprocessingResult,\n            mask: Optional[Dict[str, bool]] = None,\n            scenario_classifiers: Optional[Dict[str, Any]] = None\n    ) -> List[Dict[str, Union[str, float, bool]]]:\n        vector = (\n            vectorizers[self._vectorizer].vectorize(text_preprocessing_result)\n            if self._vectorizer\n            else np.array([])\n        )\n        weights = sorted(self._get_weights(text_preprocessing_result, vector).items(), key=lambda x: x[1], reverse=True)\n        answers = []\n        for weight in weights:\n            if weight[0] < len(self.intents):\n                cls_name = self.intents[weight[0]]\n                cls_prob = weight[1]\n                answers.append(self._answer_template(cls_name, cls_prob, cls_name == self.class_other))\n        return answers", "id": "15fa6154-6ac7-4195-8f62-b469783ac1fe", "path": "/Users/dmitrii.proskurin/PycharmProjects/sber-hackathon-2025/repos/smart_app_framework/core/basic_models/classifiers/basic_classifiers.py"}
{"name": "_get_weights", "parameters": "(\n            self,\n            text_preprocessing_result: BaseTextPreprocessingResult,\n            vector: Optional[np.ndarray] = np.array([]),\n            numb: int = 3\n    )", "start_line": 174, "end_line": 187, "content": "def _get_weights(\n            self,\n            text_preprocessing_result: BaseTextPreprocessingResult,\n            vector: Optional[np.ndarray] = np.array([]),\n            numb: int = 3\n    ):\n        weights = self._prediction(text_preprocessing_result, vector)\n        tuple_weights = sorted(\n            {i: weight for i, weight in enumerate(weights) if weight >= self.threshold}.items(),\n            key=lambda x: x[1],\n            reverse=True\n        )\n        tuple_weights = tuple_weights[:numb]  # берем numb наибольших значений весов\n        return dict(tuple_weights)", "id": "17d51418-f319-4ddc-8cca-5982afa95dfd", "path": "/Users/dmitrii.proskurin/PycharmProjects/sber-hackathon-2025/repos/smart_app_framework/core/basic_models/classifiers/basic_classifiers.py"}
{"name": "_prediction", "parameters": "(\n            self,\n            text_preprocessing_result: BaseTextPreprocessingResult,\n            vector: Optional[np.ndarray] = np.array([])\n    )", "start_line": 219, "end_line": 229, "content": "def _prediction(\n            self,\n            text_preprocessing_result: BaseTextPreprocessingResult,\n            vector: Optional[np.ndarray] = np.array([])\n    ) -> List[Any]:\n        if vector.size != 0:\n            prediction_result = self.classifier.predict_proba(\n                self.prepared(text_preprocessing_result), vector)[0].tolist()\n        else:\n            prediction_result = self.classifier.predict_proba(self.prepared(text_preprocessing_result))[0].tolist()\n        return prediction_result", "id": "2375d84c-16cc-4f0e-a483-a392250be75c", "path": "/Users/dmitrii.proskurin/PycharmProjects/sber-hackathon-2025/repos/smart_app_framework/core/basic_models/classifiers/basic_classifiers.py"}
